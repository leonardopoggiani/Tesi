# -*- coding: utf-8 -*-
"""confronto_anomalo_reale.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/126JE5h6_RegmsvhR1wVDVH4N7OKSd2YA
"""

import pandas as pd
from matplotlib import pyplot as plt
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from keras.preprocessing.sequence import TimeseriesGenerator
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
from keras.layers import Dropout
import numpy as np
import seaborn as sns
import warnings
warnings.filterwarnings("ignore")

"""Passata di preprocessing, alcuni valori hanno solo un dato di anomalous settato."""

df = pd.read_csv("dati_preprocessati.csv")

anomalous = 0
index = 0

for row in df.itertuples():
  # creo dataframe di appoggio con il giorno selezionato
  index = row[1]

  df_aux = df[df["Index"] == row[1]]

  for row_aux in df_aux.itertuples():
    if row_aux[3] == 1:
      anomalous = 1
    if anomalous == 1:
      df.loc[row[0],"Anomalous"] = 1

  anomalous = 0

print(df)
df.to_csv("preprocessato.csv")

"""Plottiamo le serie temporali di una porzione di dati con l'indicazione di anomalous. Questo plot mostra la diversità delle serie temporali anomale rispetto a quelle normali."""

df = pd.read_csv("preprocessato.csv")
del df["Unnamed: 0"]
print(df)

df = df.iloc[4000:]
plt.figure(figsize=(20,10))

plt.title("Time series e valori di anomalous")
plt.plot(df.index,df["Anomalous"],color="r")

plt.plot(df.index,df["Affluenza"],color="b")
plt.show()

"""Massimo numero di giorno "normali" presenti nel dataset."""

df = pd.read_csv("preprocessato.csv")
del df["Unnamed: 0"]

cont = 0
cont_anomalous = 0
tot_days = 0 # debugging
saved = 0

for row in df.itertuples():
  
  if row[3] == 0:
    cont+=1
  else: 
    if cont > saved:
      saved = cont
    cont_anomalous += 1
    tot_days += cont
    cont = 0

tot_days += cont_anomalous
print("Il numero massimo di giorni normali consecutivi è " + str(round(saved/23)) + " ( " + str(saved) + " righe )" + ", mentre i giorni anomali sono: " + str(round(cont_anomalous/23)) + ". I giorni totali sono " + str(round(tot_days/23)))

N = round(saved/23) - 1

"""Plotto le time-series relative alle giornati normali. Negli spazi vuoti ci sono i giorni anomali."""

# dataframe con gli N giorni normali precedenti ad un giorno anomalo
giorni_normali = df[df['Anomalous'] == 0 ]
giorni_normali.to_csv("normali.csv")

plt.figure(figsize=(40, 20))
plt.title("Giornate normali")
plt.plot(giorni_normali.iloc[4000:].index, giorni_normali['Affluenza'].iloc[4000:],marker="o")
plt.legend(loc='best', fontsize='small')
plt.xticks(fontsize=6)
plt.yticks(fontsize=18)
plt.xticks(rotation=70)
plt.show()

"""Plotto le time-series delle giornate anomale."""

giorni_anomali = df[df['Anomalous'] == 1 ]
giorni_anomali.to_csv("anomali.csv")

df = pd.read_csv("anomali.csv")

g = sns.FacetGrid(df, row="Index", height=1.7, aspect=4,)
g.map(sns.kdeplot, "Affluenza")

"""Definiamo delle funzioni che ci saranno utili in seguito:"""

## Trova il dataframe target, ovvero la finestra di N giorni normali che precedono il giorno anomalo passato come parametro

def find_df_target(anomalo) :
  ret = []
  cont = 0
  max = anomalo
  
  # trovo tutti i giorni normali precedenti 
  x = giorni_normali[giorni_normali.index <= anomalo]
  x = pd.DataFrame(x)
  normal_day_before = x.shape[0]

  if normal_day_before < N*23 :
    print("Non c'è margine per la finestra")

  min = normal_day_before - (N-1)*23

  for row in giorni_normali.itertuples():
    if (row[4] > min) & (row[4] < max):
      ret.append(row)
      cont += 1

  return ret

## conteggio dei giorni normali che precedono il giorno anomalo passato per parametro

def find_count_normal_days(anomalo) :
    cont = 0
    quanti = []
    for x in giorni_normali.itertuples():
      if x[0] < anomalo:
        cont+=1
        quanti.append(cont)
      else:
        quanti.append(0)
    
    giorni_normali["Quanti"] = quanti
    return cont

## funzione che effettua la predizione

def prediction(dataset,df,plot_df,row,cont) :
  n_input = 23
  n_features = 1

  # parametri: batch_size=32, epochs = 100
  generator = TimeseriesGenerator(dataset, dataset, length=n_input, batch_size=32)
  model = Sequential()
  model.add(LSTM(200, activation='relu', input_shape=(n_input, n_features)))
  model.add(Dropout(0.15))
  model.add(Dense(1))
  model.compile(optimizer='adam', loss='mean_squared_error')
  model.fit(generator, epochs=90)

  pred_list = []
  batch = dataset[-n_input:].reshape((1, n_input, n_features))

  for i in range(n_input):   
    pred_list.append(model.predict(batch)[0]) 
    batch = np.append(batch[:,1:,:],[[pred_list[i]]],axis=1)

  df_predict = pd.DataFrame(scaler.inverse_transform(pred_list), index=df_target[-n_input:].index, columns=['Prediction'])
  
  df_anomali = pd.read_csv("anomali.csv")
  anomalia_visualizzata = df_anomali[df_anomali["Index"] == row[1]]
  anomalia_visualizzata.to_csv("giorno_anomalo_mostrato" + str(cont) + ".csv")
  
  plt.figure(figsize=(40, 20))

  plt.subplot(212)
  plt.plot(anomalia_visualizzata.index, anomalia_visualizzata["Affluenza"],marker="o",color = "b")
  plt.plot(anomalia_visualizzata.index, df_predict['Prediction'], color='r', marker="o")
  
  plt.subplot(221)
  plt.title("Predizione")
  plt.plot(df_predict.index, df_predict["Prediction"], color='r', marker="o")
  plt.plot(df.iloc[1100:1400].index,df["Affluenza"].iloc[1100:1400],color = "b",marker="o")
  plt.legend(loc='best', fontsize='small')
  plt.xticks(fontsize=6)
  plt.yticks(fontsize=18)
  plt.xticks(rotation=70)
  
  plt.subplot(222)
  plt.plot(df_predict.index, df_predict['Prediction'], color='r', marker="o")

  plt.grid()
  plt.show()

df = pd.read_csv("preprocessato.csv")
del df["Unnamed: 0"]

controllati = []
skip = False

for row in df.itertuples():
  # condizione: giorno anomalo e posso creare una finestra di N giorni
  x = find_count_normal_days(row[0])
  if (row[3] == 1) & (x >= N*23): 

    for i in range(len(controllati)): 
      if controllati[i] == row[1]:
        skip = True  
        break

    if skip == False:
      df_target = find_df_target(row[0])
      df_target = pd.DataFrame(df_target)
      df_target.to_csv("target.csv")

      ## tolgo le colonne che non servono al momento
      del df_target["Index"]
      del df_target["_1"]
      del df_target["Anomalous"]
      del df_target["Quanti"]

      controllati.append(row[1])

      train = df_target
      scaler = MinMaxScaler()
      scaler.fit(train)
      train = scaler.transform(train)

      prediction(train,df,df_target,row,cont)
    
    skip = False

    ## break ## decommentare se si vuole vedere soltanto la prima iterazione